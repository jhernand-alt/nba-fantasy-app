<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
    <title>GO LAKERS!!!!</title>
    
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.7.1/dist/chart.min.js"></script>
    
    <link rel="stylesheet" href="styles.css"> 
</head>
<body>

    <main class="container"> 
        
        <header>
            <h1>Liga Fantasy NBA "GO LAKERS!!!!"</h1>

            <div class="controls-and-filters" role="region" aria-label="Filtros y Controles de Datos">
                <div id="unifiedControls" class="controls-row"> 
                    
                    <label for="csvFile" class="btn-download">
                        Cargar Datos CSV ‚¨ÜÔ∏è
                        <input type="file" id="csvFile" accept=".csv" style="display: none;">
                    </label>
                    <button id="downloadCSV" class="btn-download" disabled>Descargar Datos CSV ‚¨áÔ∏è</button>
                    
                    <span style="border-left: 1px solid #ccc; height: 30px; margin: 0 5px;"></span>

                    <select id="fantasyTeamSelector" class="fantasy-team-selector" onchange="filterPlayersByFantasyTeam(this.value)" disabled>
                        <option value="all">TODOS LOS EQUIPOS FANTASY</option>
                    </select>
                    
                    <div id="positionFilters" role="group" aria-label="Filtros por Posici√≥n de Jugador">
                        <button onclick="filterPlayersByPosition('all', this)" class="filter-btn active" aria-pressed="true">TODOS</button>
                        <button onclick="filterPlayersByPosition('PG', this)" class="filter-btn" aria-pressed="false">PG</button>
                        <button onclick="filterPlayersByPosition('SG', this)" class="filter-btn" aria-pressed="false">SG</button>
                        <button onclick="filterPlayersByPosition('SF', this)" class="filter-btn" aria-pressed="false">SF</button>
                        <button onclick="filterPlayersByPosition('PF', this)" class="filter-btn" aria-pressed="false">PF</button>
                        <button onclick="filterPlayersByPosition('C', this)" class="filter-btn" aria-pressed="false">C</button>
                        <button onclick="filterPlayersByPosition('G', this)" class="filter-btn" aria-pressed="false">G</button>
                        <button onclick="filterPlayersByPosition('F', this)" class="filter-btn" aria-pressed="false">F</button>
                    </div>
                </div>
            </div>
        </header>

        <section aria-labelledby="tablaJugadoresHeader">
            <h2 id="tablaJugadoresHeader">Estad√≠sticas Detalladas por Jugador</h2>
            <div class="table-wrapper">
                <table class="player-table" role="grid" aria-label="Tabla de datos de jugadores, ordenable y seleccionable">
                    <thead id="playerTableHeader">
                        <tr>
                            <th>Equipo<br>Fantasy</th>
                            <th onclick="sortTable('name', this)">Nombre</th>
                            <th onclick="sortTable('team', this)">Equipo<br>NBA</th>
                            <th>Posici√≥n(es)</th> 
                            <th onclick="sortTable('gamesPlayed', this)">Partidos<br>Jugados</th>
                            <th onclick="sortTable('totalPoints', this)">Puntos<br>Totales</th>
                            <th onclick="sortTable('averagePoints', this)">Puntos<br>Promedio</th>
                            <th>MARGEN<br>DE ERROR</th>
                        </tr>
                    </thead>
                    <tbody id="playerTableBody">
                        <tr><td colspan="8">Cargue un archivo CSV para ver los datos.</td></tr> 
                    </tbody>
                </table>
            </div>
        </section>

        <section aria-labelledby="graficoHeader">
            <h2 id="graficoHeader">Visualizaci√≥n de Puntos Diarios/Semanales</h2>
            <figure class="chart-container" role="img" aria-label="Gr√°fico de l√≠nea comparando los puntos de los jugadores filtrados">
                <div class="chart-controls">
                    <select id="chartTypeSelector" class="chart-selector" onchange="updateChartDisplay()">
                        <option value="daily">Puntos Diarios</option>
                        <option value="weekly">Puntos Semanales</option>
                    </select>
                    <button id="downloadChart" class="btn-download" disabled>Descargar Gr√°fico üñºÔ∏è</button>
                </div>
                <canvas id="pointsChart"></canvas>
            </figure>
        </section>
        
        <div class="credit-text-main">
            Hecho por Juli√°n Hern√°ndez (√öltima versi√≥n <span id="currentDatePlaceholder"></span>)
        </div>

    </main>
    
    <script>
        // --- VARIABLES GLOBALES DEL ESTADO DE LA APLICACI√ìN ---
        let allPlayerData = []; 
        let activePlayers = []; 
        let chartInstance = null; 
        let dateLabels = []; 
        let weeklyLabels = []; 
        let currentSortKey = 'totalPoints'; 
        let sortDirection = 'desc'; 
        let currentPositionFilter = 'all'; 
        let currentTeamFilter = 'all'; 
        
        // Definici√≥n de las semanas de fantas√≠a
        const fantasyWeeks = [
            { start: '21/10', end: '27/10', label: 'S1 (21/10 - 27/10)', startDay: 0, endDay: 5 }, 
            { start: '28/10', end: '03/11', label: 'S2 (28/10 - 03/11)', startDay: 6, endDay: 12 },
            { start: '04/11', end: '10/11', label: 'S3 (04/11 - 10/11)', startDay: 13, endDay: 19 },
            { start: '11/11', end: '17/11', label: 'S4 (11/11 - 17/11)', startDay: 20, endDay: 26 },
            { start: '18/11', end: '24/11', label: 'S5 (18/11 - 24/11)', startDay: 27, endDay: 33 }, 
            { start: '25/11', end: '01/12', label: 'S6 (25/11 - 01/12)', startDay: 34, endDay: 40 }, 
            { start: '02/12', end: '08/12', label: 'S7 (02/12 - 08/12)', startDay: 41, endDay: 47 },
            { start: '09/12', end: '15/12', label: 'S8 (09/12 - 15/12)', startDay: 48, endDay: 54 },
        ];
        weeklyLabels = fantasyWeeks.map(w => w.label);

        // Colores c√≠clicos para las l√≠neas del gr√°fico
        const chartColors = [
            'rgb(255, 99, 132)', 'rgb(54, 162, 235)', 'rgb(255, 205, 86)', 
            'rgb(75, 192, 192)', 'rgb(153, 102, 255)', 'rgb(255, 159, 64)',
            'rgb(199, 199, 199)', 'rgb(83, 102, 255)', 'rgb(10, 200, 100)'
        ];

        // --- FUNCIONES DE C√ÅLCULO ESTAD√çSTICO ---
        
        function calculateStdDev(arr, mean) {
            const validData = arr.filter(p => p !== null);
            if (validData.length <= 1) return 0;
            const squaredDifferences = validData.map(p => Math.pow(p - mean, 2));
            const variance = squaredDifferences.reduce((sum, val) => sum + val, 0) / (validData.length - 1);
            return Math.sqrt(variance);
        }

        function calculateMarginOfError(stdDev, n) {
            if (n < 2) return 0; 
            const Z_95 = 1.96; // Valor Z para el 95% de confianza
            return Z_95 * (stdDev / Math.sqrt(n));
        }
        
        // --- FUNCI√ìN DE PARSEO Y PROCESAMIENTO DE DATOS ---
        
        document.getElementById('csvFile').addEventListener('change', handleFileUpload);
        
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const csvText = e.target.result;
                try {
                    allPlayerData = parseCSV(csvText); 
                } catch (error) {
                    alert("Error al procesar el archivo CSV. Aseg√∫rate de que el formato es correcto (separado por ';'). Detalle: " + error.message);
                    resetDisplay();
                    return;
                }

                if (allPlayerData.length === 0) {
                    alert("El archivo CSV no contiene datos de jugadores v√°lidos.");
                    resetDisplay();
                    return;
                }
                
                // Genera las etiquetas de fechas para el eje X
                const maxDays = Math.max(0, ...allPlayerData.map(p => p.dailyPoints.length));
                dateLabels = generateDateLabels(maxDays); 
                
                initializeApplication(allPlayerData);
            };
            reader.readAsText(file);
        }

        /**
         * Parsea el texto CSV en un array de objetos de jugador.
         */
        function parseCSV(csvText) {
            const lines = csvText.trim().split('\n');
            if (lines.length <= 2) return []; 
            
            const data = [];
            
            for (let i = 2; i < lines.length; i++) { 
                const values = lines[i].split(';'); 
                
                // M√≠nimo 4 columnas de informaci√≥n + 1 d√≠a de puntos
                if (values.length >= 5) { 
                    
                    // Los puntos empiezan en el √≠ndice 4 
                    const dailyPoints = values.slice(4).map(p => {
                        const trimmed = p.trim();
                        if (trimmed === '') return null;
                        const num = parseFloat(trimmed);
                        return isNaN(num) ? null : num;
                    });
                    
                    const weeklyPoints = calculateWeeklyPoints(dailyPoints);

                    const validPoints = dailyPoints.filter(p => p !== null);
                    const totalPoints = validPoints.reduce((sum, p) => sum + p, 0);
                    const gamesPlayed = validPoints.length; 
                    
                    const averagePoints = gamesPlayed > 0 ? (totalPoints / gamesPlayed) : 0;
                    
                    const stdDev = calculateStdDev(dailyPoints, averagePoints);
                    const marginOfErrorPts = calculateMarginOfError(stdDev, gamesPlayed);
                    const marginOfErrorPct = averagePoints > 0 ? (marginOfErrorPts / averagePoints) * 100 : 0;

                    const player = {
                        fantasyTeam: values[0].trim(), 
                        name: values[1].trim(),       
                        team: values[2].trim(),       
                        position: values[3].trim().toUpperCase(), 
                        gamesPlayed: gamesPlayed, 
                        dailyPoints: dailyPoints,
                        weeklyPoints: weeklyPoints, 
                        totalPoints: totalPoints,
                        averagePoints: averagePoints,
                        marginOfErrorPts: marginOfErrorPts,
                        marginOfErrorPct: marginOfErrorPct 
                    };
                    data.push(player);
                }
            }
            return data;
        }

        function calculateWeeklyPoints(dailyPoints) {
            const weeklyTotals = [];
            const maxDays = dailyPoints.length;
            fantasyWeeks.forEach(week => {
                let weekSum = 0;
                const end = Math.min(week.endDay + 1, maxDays); 
                for (let i = week.startDay; i < end; i++) {
                    const points = dailyPoints[i];
                    if (points !== null) {
                        weekSum += points;
                    }
                }
                if (week.startDay < maxDays) {
                    weeklyTotals.push(weekSum);
                } else {
                    weeklyTotals.push(null);
                }
            });
            const firstNullIndex = weeklyTotals.findIndex(p => p === null);
            const sliceEnd = firstNullIndex !== -1 ? firstNullIndex : weeklyTotals.length;
            return weeklyTotals.slice(0, sliceEnd);
        }
        
        function generateDateLabels(numDays) {
            const startDate = new Date('2023-10-22'); 
            const labels = [];
            for (let i = 0; i < numDays; i++) {
                const currentDate = new Date(startDate);
                currentDate.setDate(startDate.getDate() + i);
                const day = currentDate.getDate();
                const month = currentDate.toLocaleString('es-ES', { month: 'short' }).replace('.', '');
                labels.push(`${day}-${month}`);
            }
            return labels;
        }

        // --- GESTI√ìN DE ESTADO (LOCAL STORAGE) ---
        
        function saveState(options = {}) {
            const state = {
                sortKey: currentSortKey,
                sortDir: sortDirection,
                posFilter: options.posFilter || currentPositionFilter,
                teamFilter: options.teamFilter || currentTeamFilter 
            };
            localStorage.setItem('fantasyAppState', JSON.stringify(state));
        }

        function loadState() {
            const savedState = localStorage.getItem('fantasyAppState');
            if (savedState) {
                try {
                    const state = JSON.parse(savedState);
                    const validKeys = ['name', 'team', 'gamesPlayed', 'totalPoints', 'averagePoints'];
                    const validDirs = ['asc', 'desc'];
                    
                    currentSortKey = validKeys.includes(state.sortKey) ? state.sortKey : 'totalPoints';
                    sortDirection = validDirs.includes(state.sortDir) ? state.sortDir : 'desc';
                    currentPositionFilter = state.posFilter || 'all';
                    currentTeamFilter = state.teamFilter || 'all'; 
                    
                    return { pos: currentPositionFilter, team: currentTeamFilter };
                } catch (e) {
                    console.error("Error al parsear el estado guardado:", e);
                    return { pos: 'all', team: 'all' };
                }
            }
            return { pos: 'all', team: 'all' };
        }


        // --- FUNCIONES DE CONTROL PRINCIPALES ---

        /**
         * Rellena el selector de equipo fantasy y lo habilita.
         */
        function populateFantasyTeamSelector() {
            const selector = document.getElementById('fantasyTeamSelector');
            selector.innerHTML = '<option value="all">TODOS LOS EQUIPOS FANTASY</option>';
            
            const teams = [...new Set(allPlayerData.map(p => p.fantasyTeam))].sort();
            
            teams.forEach(team => {
                const option = document.createElement('option');
                option.value = team;
                option.textContent = team;
                selector.appendChild(option);
            });
            
            selector.value = currentTeamFilter;
            selector.disabled = false;
        }
        
        /**
         * Punto de entrada despu√©s de cargar los datos.
         */
        function initializeApplication(data) {
            if (data.length === 0) {
                resetDisplay();
                return;
            }
            document.getElementById('downloadChart').disabled = false;
            document.getElementById('downloadCSV').disabled = false;

            const initialFilters = loadState(); 
            currentPositionFilter = initialFilters.pos;
            currentTeamFilter = initialFilters.team;
            
            currentSortKey = 'totalPoints';
            sortDirection = 'desc';
            
            populateFantasyTeamSelector(); 
            
            // Simula el clic en el bot√≥n de posici√≥n guardado
            const initialPositionButton = document.querySelector(`.filter-btn[onclick*="filterPlayersByPosition('${currentPositionFilter}')"]`);
            
            if (initialPositionButton) {
                filterPlayersByPosition(currentPositionFilter, initialPositionButton);
            } else {
                filterPlayersByPosition('all', document.querySelector('.filter-btn[onclick*="filterPlayersByPosition(\'all\')"]'));
            }
        }
        
        /**
         * Funci√≥n clave de Filtrado: Combina ambos filtros (Equipo y Posici√≥n).
         */
        function applyFilters() {
            // 1. Aplicar filtro de Equipo Fantasy
            let filteredByTeam = (currentTeamFilter === 'all' || !currentTeamFilter)
                ? [...allPlayerData]
                : allPlayerData.filter(p => p.fantasyTeam === currentTeamFilter);

            // 2. Aplicar filtro de Posici√≥n sobre el resultado del filtro de Equipo
            activePlayers = getPlayersFilteredByPosition(currentPositionFilter, filteredByTeam);
            
            // 3. Ordenar la lista activa y Renderizar la TABLA
            applySort(activePlayers);
            updatePlayerTable(activePlayers);

            // 4. Renderizar el GR√ÅFICO
            updateChartDisplay(); 

            // 5. Guardar el estado
            saveState();
        }

        /**
         * Establece el filtro de Equipo Fantasy y llama a applyFilters.
         */
        window.filterPlayersByFantasyTeam = function(teamKey) {
            currentTeamFilter = teamKey;
            applyFilters();
            saveState({ teamFilter: teamKey });
        };
        
        /**
         * Establece el filtro de Posici√≥n y llama a applyFilters.
         */
        window.filterPlayersByPosition = function(positionKey, clickedButton) {
            currentPositionFilter = positionKey.toLowerCase() === 'todos' ? 'all' : positionKey;

            // Aplicar estilos de bot√≥n
            document.querySelectorAll('#positionFilters .filter-btn').forEach(btn => {
                btn.classList.remove('active');
                btn.setAttribute('aria-pressed', 'false');
            });

            const targetButton = clickedButton || document.querySelector(`.filter-btn[onclick*="filterPlayersByPosition('${currentPositionFilter}')"]`);
            if(targetButton) {
                targetButton.classList.add('active');
                targetButton.setAttribute('aria-pressed', 'true');
            }
            
            applyFilters();
            saveState({ posFilter: currentPositionFilter });
        };


        function getPositionKeys(key) {
            switch (key.toUpperCase()) {
                case 'G': return ['PG', 'SG'];
                case 'F': return ['SF', 'PF'];
                default: return [key.toUpperCase()];
            }
        }
        
        /**
         * Devuelve los jugadores de la lista base (normalmente ya filtrados por Equipo) 
         * que coinciden con el filtro de posici√≥n.
         */
        function getPlayersFilteredByPosition(filterKey, baseData = allPlayerData) {
             let filteredByPosition = [];
             const normalizedKey = filterKey.toLowerCase();

             if (normalizedKey === 'all' || normalizedKey === 'todos') {
                filteredByPosition = [...baseData];
            } else {
                const positionKeys = getPositionKeys(filterKey);
                
                filteredByPosition = baseData.filter(player => {
                    const playerPositions = player.position.split(/[\/,]/).map(p => p.trim());
                    
                    return playerPositions.some(pos => positionKeys.includes(pos));
                });
            }
            return filteredByPosition;
        }

        function applySort(data) {
            data.sort((a, b) => {
                const key = currentSortKey;
                const valueA = a[key];
                const valueB = b[key];
                
                if (['name', 'team'].includes(key)) { 
                    const comparison = String(valueA).localeCompare(String(valueB));
                    return sortDirection === 'asc' ? comparison : -comparison;
                } else { 
                    const valA = valueA || 0;
                    const valB = valueB || 0;
                    return sortDirection === 'asc' ? valA - valB : valB - valA;
                }
            });
        }
        
        window.sortTable = function(key, clickedElement) {
            
            if (currentSortKey === key) {
                sortDirection = (sortDirection === 'asc') ? 'desc' : 'asc';
            } else {
                sortDirection = 'desc'; 
                currentSortKey = key;
            }

            applySort(activePlayers);
            
            updatePlayerTable(activePlayers);
            updateChartDisplay(); 
            
            saveState();
        }

        // --- FUNCIONES DE RENDERIZADO (VISTAS) ---
        
        function updatePlayerTable(data) {
            const tableBody = document.getElementById('playerTableBody');
            tableBody.innerHTML = ''; 
            
            // Definici√≥n de encabezados con formato de dos l√≠neas
            const headers = [
                { key: 'fantasyTeam', label: 'Equipo Fantasy', sortable: false, labelHtml: 'Equipo<br>Fantasy' }, 
                { key: 'name', label: 'Nombre', sortable: true, labelHtml: 'Nombre' },
                { key: 'team', label: 'Equipo NBA', sortable: true, labelHtml: 'Equipo<br>NBA' },
                { key: 'position', label: 'Posici√≥n(es)', sortable: false, labelHtml: 'Posici√≥n(es)' }, 
                { key: 'gamesPlayed', label: 'Partidos Jugados', sortable: true, labelHtml: 'Partidos<br>Jugados' },
                { key: 'totalPoints', label: 'Puntos Totales', sortable: true, labelHtml: 'Puntos<br>Totales' },
                { key: 'averagePoints', label: 'Puntos Promedio', sortable: true, labelHtml: 'Puntos<br>Promedio' },
                { key: 'margin', label: 'MARGEN DE ERROR', sortable: false, labelHtml: 'MARGEN<br>DE ERROR' }, 
            ];
            
            const headerRow = document.createElement('tr');
            headers.forEach(header => {
                const th = document.createElement('th');
                th.innerHTML = header.labelHtml; 
                th.setAttribute('aria-sort', 'none');
                
                if (header.sortable) { 
                    th.setAttribute('onclick', `sortTable('${header.key}', this)`);
                    if (header.key === currentSortKey) {
                        const icon = sortDirection === 'asc' ? ' ‚ñ≤' : ' ‚ñº';
                        th.innerHTML = header.labelHtml + icon; 
                        th.setAttribute('aria-sort', sortDirection === 'asc' ? 'ascending' : 'descending');
                    }
                } else {
                    th.style.cursor = 'default';
                }
                
                headerRow.appendChild(th);
            });

            document.getElementById('playerTableHeader').innerHTML = '';
            document.getElementById('playerTableHeader').appendChild(headerRow);
            
            // GENERAR FILAS DE DATOS
            if (data.length === 0) {
                 tableBody.innerHTML = '<tr><td colspan="8">No hay jugadores que coincidan con los filtros aplicados.</td></tr>';
                 return;
            }
            
            data.forEach(player => {
                const row = tableBody.insertRow();
                
                row.insertCell().textContent = player.fantasyTeam; 
                row.insertCell().textContent = player.name;
                row.insertCell().textContent = player.team; 
                row.insertCell().textContent = player.position; 
                row.insertCell().textContent = player.gamesPlayed; 
                row.insertCell().textContent = player.totalPoints.toFixed(2); 
                row.insertCell().textContent = `${player.averagePoints.toFixed(2)}`; 
                
                const marginCell = row.insertCell();
                const pts = player.marginOfErrorPts.toFixed(2);
                const pct = player.marginOfErrorPct.toFixed(1);
                marginCell.textContent = `¬± ${pts} (${pct}%)`;
            });
        }
        
        window.updateChartDisplay = function() {
            const chartType = document.getElementById('chartTypeSelector').value;
            renderChart(activePlayers, chartType); 
        }

        function renderChart(players, chartType) {
             if (chartInstance) {
                chartInstance.destroy();
            }
            
            const ctx = document.getElementById('pointsChart').getContext('2d');
            
            const isDaily = chartType === 'daily';
            const labels = isDaily ? dateLabels : weeklyLabels;
            const dataKey = isDaily ? 'dailyPoints' : 'weeklyPoints';
            const yAxisLabel = isDaily ? 'Puntos Anotados (Diario)' : 'Puntos Anotados (Semanal)';

            const playerDatasets = players.map((player, index) => {
                const color = chartColors[index % chartColors.length];
                
                const dataSlice = player[dataKey] ? player[dataKey].slice(0, labels.length) : [];
                
                return {
                    label: player.name,
                    data: dataSlice, 
                    borderColor: color,
                    backgroundColor: color,
                    tension: 0.2, 
                    borderWidth: 2,
                    fill: false, 
                    pointRadius: 4,
                    spanGaps: isDaily 
                };
            });
            
            if (playerDatasets.length === 0) {
                 return;
            }
            
            // --- C√ÅLCULO DE LA L√çNEA DE PROMEDIO GLOBAL (RECTA) ---
            
            // 1. Sumamos el Puntos Promedio (Puntos/Partidos Jugados) de todos los jugadores filtrados
            const totalAvgPoints = players.reduce((sum, p) => sum + p.averagePoints, 0);
            
            // 2. Calculamos el promedio global de esos promedios
            const overallAverage = players.length > 0 ? totalAvgPoints / players.length : 0;

            // 3. Creamos un array de datos que repite ese promedio fijo para cada punto del eje X (l√≠nea recta)
            const numLabels = labels.length;
            const fixedAverageData = new Array(numLabels).fill(overallAverage.toFixed(2));
            

            const averageDataset = {
                label: `PROMEDIO GLOBAL (${overallAverage.toFixed(2)} pts)`,
                data: fixedAverageData,
                borderColor: 'rgba(0, 0, 0, 0.8)', 
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                borderWidth: 3,
                borderDash: [5, 5], // L√≠nea punteada para diferenciar
                tension: 0, // Fuerza la l√≠nea recta
                fill: false,
                pointRadius: 0, 
                order: 0, 
                spanGaps: false, // Importante para la l√≠nea recta
            };
            
            const datasets = [averageDataset, ...playerDatasets];


            chartInstance = new Chart(ctx, {
                type: 'line', 
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false, 
                    layout: {
                        padding: {
                            bottom: 40 
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                        },
                        title: {
                            display: false,
                            text: ''
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: yAxisLabel 
                            }
                        },
                        x: {
                            afterFit: function(scale) {
                                scale.paddingBottom = 20; 
                            },
                        }
                    }
                }
            });
        }
        
        /**
         * Funci√≥n de descarga del gr√°fico con fondo blanco forzado.
         */
        window.downloadChartImage = function() {
            if (!chartInstance) {
                alert("No hay un gr√°fico para descargar.");
                return;
            }
            
            // Usamos el canvas del chartInstance para mayor fiabilidad
            const canvas = chartInstance.canvas; 
            
            // 1. Crear un nuevo canvas temporal para el fondo blanco
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');

            // 2. Dibujar el fondo blanco
            tempCtx.fillStyle = '#FFFFFF';
            tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

            // 3. Dibujar el contenido del gr√°fico encima (incluyendo las l√≠neas y puntos)
            tempCtx.drawImage(canvas, 0, 0);

            // 4. Descargar la imagen del canvas temporal
            const image = tempCanvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.href = image;
            link.download = 'grafico_puntos_fantasy.png';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function downloadCSV() {
            if (allPlayerData.length === 0) {
                alert("No hay datos para descargar. Por favor, carga un archivo primero.");
                return;
            }

            const maxDays = dateLabels.length;
            // Encabezados con el nuevo campo
            let csvContent = "Equipo Fantasy;Nombre;Equipo NBA;Posicion;" + Array.from({length: maxDays}, (_, i) => `D√≠a ${i + 1}`).join(';') + "\n";
            csvContent += "Equipo Fantasy;Nombre;Equipo NBA;Posicion;" + dateLabels.join(';') + "\n";
            
            allPlayerData.forEach(player => {
                const points = player.dailyPoints.map(p => p === null ? '' : p).join(';');
                // Incluye el nuevo campo
                csvContent += `${player.fantasyTeam};${player.name};${player.team};${player.position};${points}\n`;
            });

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.setAttribute("href", url);
            link.setAttribute("download", "datos_nba_export_v2.csv"); 
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        function resetDisplay() {
             localStorage.removeItem('fantasyAppState');
             allPlayerData = []; 
             activePlayers = []; 
             
             // Encabezados predeterminados con 8 columnas
             const headerRow = `<tr>
                <th>Equipo<br>Fantasy</th>
                <th onclick="sortTable('name', this)">Nombre</th>
                <th onclick="sortTable('team', this)">Equipo<br>NBA</th>
                <th>Posici√≥n(es)</th>
                <th onclick="sortTable('gamesPlayed', this)">Partidos<br>Jugados</th>
                <th onclick="sortTable('totalPoints', this)" aria-sort="descending">Puntos<br>Totales</th>
                <th onclick="sortTable('averagePoints', this)" aria-sort="none">Puntos<br>Promedio</th>
                <th>MARGEN<br>DE ERROR</th>
             </tr>`;
             document.getElementById('playerTableHeader').innerHTML = headerRow;

             document.getElementById('playerTableBody').innerHTML = '<tr><td colspan="8">Cargue un archivo CSV para ver los datos.</td></tr>'; 
             
             if (chartInstance) {
                chartInstance.destroy(); 
             }
             document.getElementById('downloadCSV').disabled = true;
             document.getElementById('downloadChart').disabled = true; 
             document.getElementById('fantasyTeamSelector').disabled = true;
             document.getElementById('fantasyTeamSelector').innerHTML = '<option value="all">TODOS LOS EQUIPOS FANTASY</option>';

             document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.classList.remove('active');
                btn.setAttribute('aria-pressed', 'false');
             });
             
             currentSortKey = 'totalPoints';
             sortDirection = 'desc';
             currentPositionFilter = 'all';
             currentTeamFilter = 'all';
             
             const allButton = document.querySelector('.filter-btn[onclick*="filterPlayersByPosition(\'all\')"]');
             if (allButton) {
                 allButton.classList.add('active');
                 allButton.setAttribute('aria-pressed', 'true');
             }
             
             document.getElementById('chartTypeSelector').value = 'daily';

             dateLabels = [];
        }

        // --- FUNCI√ìN PARA MOSTRAR LA FECHA ACTUAL ---
        function updateCreditDate() {
            const now = new Date();
            const options = { day: '2-digit', month: '2-digit', year: 'numeric' };
            const formattedDate = now.toLocaleDateString('es-ES', options);
    
            const dateElement = document.getElementById('currentDatePlaceholder');
            if (dateElement) {
                dateElement.textContent = formattedDate;
            }
        }

        // --- INICIALIZACI√ìN AL CARGAR LA P√ÅGINA ---
        window.onload = function() {
            // 1. Inicializa la fecha din√°mica
            updateCreditDate(); 
            
            // 2. Restablece el estado de la aplicaci√≥n
            resetDisplay();
            renderChart([], 'daily'); 
            
            // 3. Asigna la funci√≥n de descarga al bot√≥n.
            document.getElementById('downloadChart').addEventListener('click', downloadChartImage);
        };
    </script>
</body>

</html>